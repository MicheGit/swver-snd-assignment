\section{Abstract Interpreter}

\subsection{Abstract States}

\begin{frame}{Abstract States (1)}
    We define for any abstract domain $A$, which is a complete lattice as well, the abstract state type $\mathbb{S}_{A} = Map(Var, A)$.
    
    \begin{alertblock}{Assumption}
        When a variable is used before its definition, then its value is assumed to be ``unknown'' ($\top_{A}$). This is due to the fact that we assume that all referenced variables in the program are initialized.
        %% Non è affare nostro sapere se ci sono delle variabili non inizializzate, bensì ci occorre sapere se il programma termini in maniera corretta
    \end{alertblock}
\end{frame}

\begin{frame}{Abstract States (2)}

    Moreover, $\bot_{\mathbb{S}_{A}}$ represents an abnormal termination (no update operation can be performed over this state):

    \begin{flalign*}
        s(x) &= \begin{cases}
            a & (x, a) \in s \\
            \top_{A} & otherwise 
        \end{cases} \\
        s[x \mapsto a] &= \begin{cases}
            \bot_{\mathbb{S}_{A}} & s = \bot_{\mathbb{S}_{A}} \\
            \{ (k, v) \pipe (k, v) \in s,\,\,k\neq x \} & a \neq \top_{A},\,\,s \neq \bot_{\mathbb{S}_{A}}\\
            \{ (k, v) \pipe (k, v) \in s,\,\,k\neq x \}  & otherwise
        \end{cases}
    \end{flalign*}

    
\end{frame}


\begin{frame}{Abstract States (3)}
    \begin{exampleblock}{$\mathbb{S}_{A}$ is partially ordered}
        \[ s_1 \leq_{\mathbb{S}_A} s_2 \iff s_1(x) \leq_A s_2(x)\,\,\forall x \in Var \]
    \end{exampleblock}

    \begin{exampleblock}{$\mathbb{S}_{A}$ is a complete lattice}
        \begin{flalign*}
            \bot_{\mathbb{S}_{A}} &= \{ (x, \bot_{A}) \pipe x \in Var \} \\
            \top_{\mathbb{S}_{A}} &= \emptyset \\
            s_1 \lor_{\mathbb{S}_{A}} s_2  &= \{ (var, a_1 \lor_{A} a_2) \pipe (var, a_1) \in s_1, (var, a_2) \in s_2 \} \\
            s_1 \land_{\mathbb{S}_{A}} s_2  &= \{ (var, a_1 \land_{A} a_2) \pipe (var, a_1) \in s_1, (var, a_2) \in s_2 \} \\
            &\cup \{ e \pipe e \in s_1, e \notin s_2 \} \cup \{ e \pipe e \notin s_1,e \in s_2 \} \\
        \end{flalign*} 
    \end{exampleblock} 
\end{frame}

\subsection{Abstract Semantics}

\begin{frame}{Abstract Semantics}
    The abstract semantic functions are:
    \begin{itemize}
        \item $\mathcal{A}^\sharp : AExp \to \mathbb{S}_{A} \to A \times \mathbb{S}_{A}$:
        \begin{itemize}
            \item the first element of the tuple approximates the possible results of the arithmetic expression;
            \item the second element approximates the possible states after the transition induced by the expression;
        \end{itemize}
        \item $\mathcal{B}^\sharp : BExp \to \mathbb{S}_{A} \to \mathbb{S}_A \times \mathbb{S}_A$;
        \begin{itemize}
            \item the first element of the tuple approximates the states where the boolean expression can evaluate to \textbf{tt};
            \item the second element approximates the states where the boolean expression can evaluate \textbf{ff}.
        \end{itemize}
        This function returns two states, instead of one, in order to preserve the short circuit behavior of boolean operators along with a compositional definition.
        %% per mantenere rappresentato lo short-circuit degli operatori logici mantenendo la definizione composizionale era necessario che la funzione B# restituisse anche lo stato in caso BExp valutasse a falso
        \item $\mathcal{D}^\sharp : While \to \mathbb{S}_{A} \to\mathbb{S}_{A}$.
    \end{itemize}
\end{frame}

\begin{frame}{Abstract Semantics - Statements (1)}
    \begin{exampleblock}{$\mathcal{D}^\sharp : While \to \mathbb{S}_{A} \to \mathbb{S}_{A}$}
        
        \begin{flalign*}
            \asem{D}{x\texttt{ := }e} s^{\sharp} & \defas
            \begin{cases}
                s'^\sharp [x \mapsto a] & (a, s'^\sharp) = \asem{A}{e} s^\sharp\\ 
                & \land a \neq \bot_A \\
                \bot_{\mathbb{S}_{A}} & otherwise
            \end{cases}\\
            \asem{D}{\texttt{skip}} s^{\sharp} & \defas s^{\sharp} \\
            \asem{D}{S_1\texttt{ ; }S_2} s^{\sharp} & \defas (\asem{D}{S_1} \circ \asem{D}{S_2}) s^{\sharp}
        \end{flalign*}
    \end{exampleblock}
\end{frame}

\begin{frame}{Abstract Semantics - Statements (2)}
    \begin{exampleblock}{$\mathcal{D}^\sharp : While \to \mathbb{S}_{A} \to \mathbb{S}_{A}$}
        
        \small\begin{flalign*}
            \asem{D}{\texttt{if }b\texttt{ then }S_1\texttt{ else }S_2} s^{\sharp} & \defas (\asem{B}{S_1} s^{\sharp}_{\mathbf{tt}}) \lor_{\mathbb{S}_A} (\asem{B}{S_2} s_{\mathbf{ff}}^{\sharp}) \\
            where &\quad\,\,\, (s^{\sharp}_{\mathbf{tt}}, s_{\mathbf{ff}}^{\sharp}) = \asem{B}{b} s^{\sharp}\\
            \asem{D}{\texttt{while }b\texttt{ do }S} s^{\sharp} & \defas \pi_2 (\asem{B}{b} (\text{GFP}_{\text{FIX } F} (\lambda s.s \land_{\mathbb{S}_A} F\,\,s))) \\
            where &\quad\,\,\, F: \mathbb{S}_A \to \mathbb{S}_A \\
            &\quad\,\,\, F\,\,s = s^{\sharp} \lor_{\mathbb{S}_A} (\asem{D}{S} \circ \pi_1 \circ \asem{B}{b} s) \\
        \end{flalign*}
    \end{exampleblock}

    \small{Where FIX $F$ refers to the fixed point of the function $F$ and GFP$_s$ $f$ is the greatest fixed point of $f$ found starting from $s$.}
\end{frame}

